<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Sxiaojian]]></title>
  <subtitle><![CDATA[努力工作]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://sxiaojian.com/"/>
  <updated>2017-05-12T10:43:35.000Z</updated>
  <id>http://sxiaojian.com/</id>
  
  <author>
    <name><![CDATA[Sxiaojian的博客]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS如何获取系统蓝牙日志]]></title>
    <link href="http://sxiaojian.com/2017/05/12/How-to-get-iOS-system-Bluetooth-logs/"/>
    <id>http://sxiaojian.com/2017/05/12/How-to-get-iOS-system-Bluetooth-logs/</id>
    <published>2017-05-12T10:02:04.000Z</published>
    <updated>2017-05-12T10:43:35.000Z</updated>
    <content type="html"><![CDATA[<p>iOS10的日志系统，已经不再有单独的蓝牙日志文件了，日志信息被记录在<strong>system_logs.logarchive</strong>文件中，可以被Mac OS系统应用Console打开。下面就是iPhone与Apple Watch获取系统诊断日志的步骤：</p>
<h2 id="iPhone">iPhone</h2><ol>
<li>下载描述文件<a href="http://7xiyql.com1.z0.glb.clouddn.com/BluetoothWirelessProximity_iOS10.mobileconfig" target="_blank" rel="external">profile</a>，安装在iOS设备上。</li>
<li>如果提示重启则重启</li>
<li>记录问题发生的日期时间</li>
<li>出发系统诊断日志模式（同时按住音量加、音量减与电源键），开启成功iPhone会有一个短的震动</li>
<li>系统会收集诊断日志信息，需要等待十分钟左右完成</li>
<li>用iTunes同步iPhone，同步完成后可以在下面路径找到日志文件。</li>
</ol>
<h2 id="Watch">Watch</h2><ol>
<li>下载描述文件<a href="http://7xiyql.com1.z0.glb.clouddn.com/BluetoothWirelessProximity_iOS10.mobileconfig" target="_blank" rel="external">profile</a>，安装在iOS设备上。</li>
<li>如果提示选择设备，选择Apple Watch</li>
<li>重启Apple Watch，在Setting&gt;Logging中开启日志</li>
<li>记录问题</li>
<li>在iPhone中打开Watch app，Setting&gt;Logging，然后点Collect Logs（等待日志同步到iPhone）</li>
<li>用iTunes同步iPhone，同步完成后可以在下面路径找到日志文件。</li>
</ol>
<h2 id="iPhone日志文件位置">iPhone日志文件位置</h2><p>macOS：<br><code>~/Library/Logs/CrashReporter/MobileDevice/[Your_Device_Name]/DiagnosticLogs/sysdiagnose</code></p>
<p>Windows 8, 7, and Vista:<br><code>C:\Users\[Your_User_Name]\AppData\Roaming\Apple Computer\Logs\CrashReporter\MobileDevice\
 [Your_Device_Name]\DiagnosticLogs\sysdiagnose</code></p>
<h2 id="Watch日志文件位置">Watch日志文件位置</h2><p>macOS：<br><code>~/Library/Logs/CrashReporter/MobileDevice/[Your_Device_Name]/ProxiedDevice-[UUID]/</code></p>
<p>Windows 8, 7, and Vista:<br><code>C:\Users\[Your_User_Name]\AppData\Roaming\Apple Computer\Logs\CrashReporter\MobileDevice\
 [Your_Device_Name]\ProxiedDevice-[UUID]\</code></p>
<h2 id="禁用日志">禁用日志</h2><p><strong>iphone</strong>：Settings General Profiles，点击蓝牙描述文件，移除然后重启<br><strong>AppleWatch</strong>：打开Watch app，下滑到Profiles，点击删除，然后重启</p>
<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen Shot 2017-05-12 at 5.18.41 PM.png" alt="Screen Shot 2017-05-12 at 5.18.41 PM"><br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen Shot 2017-05-12 at 5.27.34 PM.png" alt="Screen Shot 2017-05-12 at 5.27.34 PM"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS10的日志系统，已经不再有单独的蓝牙日志文件了，日志信息被记录在<strong>system_logs.logarchive</strong>文件中，可以被Mac OS系统应用Console打开。下面就是iPhone与Apple Watch获取系统诊断日志的步骤：</]]>
    </summary>
    
      <category term="iOS" scheme="http://sxiaojian.com/tags/iOS/"/>
    
      <category term="蓝牙" scheme="http://sxiaojian.com/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hook京东iOS客户端]]></title>
    <link href="http://sxiaojian.com/2016/07/05/hook-jingdong-iosapp/"/>
    <id>http://sxiaojian.com/2016/07/05/hook-jingdong-iosapp/</id>
    <published>2016-07-05T09:35:23.000Z</published>
    <updated>2016-07-05T10:35:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><h2 id="需要的软件">需要的软件</h2><ul>
<li>iOS App signer <a href="https://github.com/DanTheMan827/ios-app-signer" title="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="external">链接</a></li>
<li>MachOView yololib <a href="https://github.com/zhengmin1989/iOS_ICE_AND_FIRE" title="https://github.com/zhengmin1989/iOS_ICE_AND_FIRE" target="_blank" rel="external">链接</a></li>
<li>ideviceinstaller    <code>brew install ideviceinstaller</code></li>
</ul>
<h2 id="需要的材料">需要的材料</h2><ul>
<li>京东客户端，已砸壳版，可以去pp助手等助手类网站下载，省去了自己砸壳的过程</li>
<li>开发者账号，个人、企业都可以</li>
<li>某一动态库，本文不介绍动态库如何写，如何生成。文章中我选用的是<a href="https://github.com/qiaoxueshi/FLEXDynamicLibProject" title="https://github.com/qiaoxueshi/FLEXDynamicLibProject" target="_blank" rel="external">链接</a></li>
<li>iPhone，非越狱即可</li>
</ul>
<h1 id="开始">开始</h1><h2 id="动态库文件与bin文件">动态库文件与bin文件</h2><p>解压京东客户端的ipa文件，取出bin二进制执行文件。执行<br><code>./yololib [被插入dylib的二进制文件] [要插入的dylib]</code></p>
<p>是否插入成功，可用MachOView这个软件查看</p>
<p>对动态库进行签名</p>
<p>｀codesign -f -s “iPhone Developer: xxxxxxx@gmail.com (XXXXXXXXX)” FLEXDylib.dylib｀</p>
<p>然后将两个文件都拷贝到JD4iPhone.app文件夹中</p>
<h2 id="embedded-mobileprovision">embedded.mobileprovision</h2><p>创建一个新的工程，bundleID写一个新的。（用线上app的bundleID无法进行签名）</p>
<p>如果无法运行，按照提示fix issue，或者换个bundleID。</p>
<p>编译运行成功后，打开声称的.app文件夹，找到embedded.mobileprovision这个文件，拷贝到JD4iPhone.app文件夹中。</p>
<h2 id="多个target">多个target</h2><p>京东客户端有Today Extension 与 Watch Extension，签名比较麻烦，我采用简单粗暴的方式，直接删除。<br>在JD4iPhone.app文件夹中，删除PlugIns文件夹</p>
<h2 id="使用iOS_App_signer_进行签名">使用iOS App signer 进行签名</h2><ul>
<li>打开iOS App signer。</li>
<li>Input File 选择 JD4iPhone.app文件夹</li>
<li>证书选择你的证书，生成embedded.mobileprovision用的证书</li>
<li>Provisionning Profile 选择对应bundleID的Provisionning Profile</li>
<li>后面两项为可选，可不填</li>
<li>点击start，选择目标路径，最后会生成ipa安装包</li>
</ul>
<h2 id="安装">安装</h2><p>使用 ideviceinstaller 这个命令行工具可清楚的看到哪一步安装失败。</p>
<p>｀ideviceinstaller -i JD4iPhone.ipa｀</p>
<h2 id="最后">最后</h2><p>如果安装成功了，会提示证书需要信任，去设置－通用－描述文件，信任一下就可以了。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/2016-07-05_Screen%20Shot%202016-07-05%20at%206.21.29%20PM.png" alt=""></p>
<h2 id="参考文章">参考文章</h2><p>详细教程请点击 <a href="http://drops.wooyun.org/papers/12803" target="_blank" rel="external">iOS冰与火之歌番外篇 - 在非越狱手机上进行App Hook</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="准备工作">准备工作</h1><h2 id="需要的软件">需要的软件</h2><ul>
<li>iOS App signer <a href="https://github.com/DanTheMan827/ios-app-signer" title="http]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[在terminal中使用shadowsocks]]></title>
    <link href="http://sxiaojian.com/2016/07/04/terminal-shadowsocks/"/>
    <id>http://sxiaojian.com/2016/07/04/terminal-shadowsocks/</id>
    <published>2016-07-04T05:37:49.000Z</published>
    <updated>2016-07-04T05:38:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装proxifier">安装proxifier</h2><p>使用proxifier。<a href="https://www.proxifier.com/distr/ProxifierMac.zip" target="_blank" rel="external">下载点我</a>   </p>
<p>注册用这个<code>P427L-9Y552-5433E-8DSR3-58Z68</code>  </p>
<p>进入后配置好本地ip 127.0.0.1 和本地端口 1080 type为socks5 ，就可以使用了。  </p>
<p>优点  </p>
<ul>
<li>自定义每个应用设置是否proxy</li>
<li>自定义host是否proxy</li>
<li>不影响浏览器是否全局</li>
<li>查看当前连接</li>
</ul>
<p>推荐shadowsocks产品<br><a href="https://my.shadowsocksr.com/aff.php?aff=136" target="_blank" rel="external">https://my.shadowsocksr.com/aff.php?aff=136</a><br>目前正在用的ss服务商，速度很快。不喜欢推广链接的朋友可以去掉后缀</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装proxifier">安装proxifier</h2><p>使用proxifier。<a href="https://www.proxifier.com/distr/ProxifierMac.zip" target="_blank" rel="external]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[autolayout布局流程]]></title>
    <link href="http://sxiaojian.com/2016/03/31/auto-layout-pass/"/>
    <id>http://sxiaojian.com/2016/03/31/auto-layout-pass/</id>
    <published>2016-03-31T08:23:01.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="autolayout布局流程">autolayout布局流程</h1><p>在AppKit和Foundation的frameworks中，布局是最基本的工作。我们在build应用程序时，AutoLayout是我们最常接触的，但有时它会让人迷惑，所以今天我想从Auto Layout的不容易理解的几个方面讲起。</p>
<h3 id="The_Layout_Cycle">The Layout Cycle</h3><p>你可能知道如何配置用户界面了，但是Auto Layout仍然像一个黑盒一样，当你配置一些东西，运行你的工程，希望界面按照你想的布局，但是却不是这样。很难知道是哪出问题了，我们如何通过设置view的constraints来给view设置frames。现在我们预览一下这个过程</p>
<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%205.56.43%20PM.png" alt=""><br>我们开启application runloop去循环的查询直到constraint的改变导致计算的布局发生改变，这就导致一个defferred layout pass将会执行。当layout pass 真正执行了，我们会更新views的frames（we go through the hierarchy，and update all the<br>frames for the views）。<br>这有一点点抽象，所以我做了一个例子。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%206.25.37%20PM.png" alt=""><br>当我们反选上面的checkbox时，我们将修改一个constraint来缩小这个window，并且隐藏下面的checkboxes。当我们改变constraint时，layout engine内部已经改变了，但是界面还没有更新。当layout pass执行时，界面才最终按照engine的方式更新。</p>
<h3 id="constraints_changes">constraints changes</h3><p>创建的约束最终会变成数学表达式放在layout engines里。所以约束的任何改变都会影响这些表达式，包括很明显的改变比如activating constraints、deactivating constraints、改变 priority和改变constant，还有一些不明显的，比如改变视图层级，因为这会间接的导致constraints的改变。</p>
<p>那么，当约束改变的时候，真正发生了什么呢？首先layout engine 会重新计算布局。那些表达式是由变量组成，这些变量描述了view的大小位置。当重新计算布局的时候，这些变量的值会更新，然后通知变量所描述的view，将它标记为 needing layout。整个过程就导致了 deferred layout pass 将会执行。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%207.30.04%20PM.png" alt=""></p>
<h3 id="defferred_layout_pass">defferred layout pass</h3><p>在我们的例子中，frame实际上在layout engine中改变了，但并没有在界面中改变，那么当 deferred layout pass 执行了，它的目的就是重新布局所有的位置不正确的views，所以完成以后，一切都正确布局了。</p>
<p>psss这个词 实际上有点用词不当。实际上有几个过程。首先就是updating constraints。updating constraints是为了确保是否有将要发生的constraints的改变。这些改变要在我们改变界面层次或者重新布局views之前。第二个过程是重新布局views了。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%207.51.45%20PM.png" alt=""><br>views需要明确的要求它们的update constraints方法被调用。这个方法做的事情与setNeedsDisplay差不多。当你调用setNeedsUpdateConstraints,一会update constraints方法就会调用。这些方法都试味了让views的constrains的改变能及时的赶上下一个 layout pass，但它并不是很常用。你所有的约束正常应该在 Interface Builder中创建，或者在代码中创建，在代码中创建时，放在viewDidLoad里会更好。Update constraints是周期性的重复工作的，所以当你需要改变constraints时，直接改就可以了。</p>
<p>如果你发现直接改constraints太慢了，那么update constraints会帮助你。在update constraints里改constraints会在比别的地方更快。原因是layout engine 能够对这个过程中的改变进行批处理，得益于批处理，对view的整个constraints数组进行批量改变也可以很快。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%208.13.48%20PM.png" alt=""><br>一个常见的模式就是为了不同的配置重新建立不同的constraints，用setNeedsUpdateConstraints就简单而高效。</p>
<p>在任何情况下，一旦这个过程（updating constraints）完成了，我们就可以认为constrains就是最新的了，我们就准备好了开始重新布局views了。这就是我们改变视图层次的地方，我们将对标记为eeding layout的views调用layoutSubviews，在OS X系统中，这个方法叫做layout，意思一样。目的是让接收者重新布局它的子视图，而不是它自己。系统会将子视图的frames从layout engine读取出来并负值给子视图。在MAC OS X调用setFrame，在iOS调用setBounds和setCenter，意思是一样的。 这就是界面真正更新的时候。</p>
<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-30%20at%208.57.52%20PM.png" alt=""><br>第二个过程就是layoutSubviews，很多人为了某种自定义的布局会复写这个方法，如果你真的需要的话就这么做，但是你需要知道这会很容易引起麻烦。所以为我想详细的说说这个问题。</p>
<p>只有在 为了实现某种constraints无法表达的布局 时，才复写layoutSubviews方法。如果你能用constraints实现，即使复杂粗暴，也会少麻烦。</p>
<p>如果你真的选择复写这个方法，那么你要记住，我们处于layout的中间过程，有些views已经布局好了，有些还没有，可能马上就布局好了。这是一个微妙的时刻。</p>
<p>有些特殊的规则需要遵守。</p>
<ul>
<li>你需要调用super layoutSubviews。这是为了各种目的。你还可以取消（invalidate）子视图的所有的布局，但是必须在super layoutSubviews之前。</li>
<li>不要调用setNeedsUpdateConstraints。因为我们已经完成了update constraints过程。如果我们真的需要调用，已经晚了。</li>
<li>不要取消（invalidate）view子视图以外的视图的布局。如果你做了，很容易引起反馈循环（feedback loops）。并且导致布局过程出问题。所以我们应该不要引发这种循环反应。</li>
</ul>
<p>你会经常发现为了让你的视图放在正确的位置你需要在你复写的layoutSubviews里尼修改constraints，这样是可以的，但是你要小心。很难预测当你修改一个constraint时，别的地方的视图会不会受影响。如果你改变了constraints，很容易导致子视图以外的视图的布局失效（invalidate）。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-31%20at%202.44.06%20PM.png" alt=""></p>
<h3 id="the_layout_cycle">the layout cycle</h3><p>在任何情况下，假设所有过程都顺利进行，layout cycle 会在这个点完成，所有的视图都在正确的位置，我们修改的constraints已经起完全起作用了。关于layout cycle 需要注意几点：</p>
<ul>
<li>当你修改constraints时，不要期望view的frame会立即改变。我们刚刚说了都会发生哪些过程。  </li>
<li>如果复写了layoutSubviews，注意不要引起反馈循环(feedback loops)，因为这很难调适<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/Screen%20Shot%202016-03-31%20at%202.45.09%20PM.png" alt=""></li>
</ul>
<h3 id="How_View_Controller_Participate_in_the_View_Layout_Process">How View Controller Participate in the View Layout Process</h3><p><img src="http://cdn1.infoqstatic.com/statics_s2_20160414-0116u1/resource/articles/ios-app-arch-2-1/zh/resources/autolayout.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="autolayout布局流程">autolayout布局流程</h1><p>在AppKit和Foundation的frameworks中，布局是最基本的工作。我们在build应用程序时，AutoLayout是我们最常接触的，但有时它会让人迷惑，所以今天我想从Aut]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS实现曲线渐变]]></title>
    <link href="http://sxiaojian.com/2015/11/30/iOS-curve-gradient/"/>
    <id>http://sxiaojian.com/2015/11/30/iOS-curve-gradient/</id>
    <published>2015-11-30T10:04:52.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="圆形渐变">圆形渐变</h3><p>最近产品提了一个需求，要求进度条的进度可以大于1。效果如下<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/progress.gif" alt=""><br>效果图上卡，实际上并不卡。<br>在开始做之前，看了github上所有的progress相关的代码，发现并没有人实现过这样的效果。苹果apple watch应用实现了，但是不知道苹果是怎么实现的。<br>这个效果的难度就在于 曲线渐变 和 进度能大于1。<br>cocoa touch提供的api都是直线渐变。而进度可以大于1要求曲线的首和尾颜色不能想近，应该相差最大。<br><a href="http://blog.csdn.net/zhoutao198712/article/details/20864143" target="_blank" rel="external">iOS实现一个颜色渐变的弧形进度条</a><br>这篇文章实现了一个曲线渐变，但是这个无法实现进度条大于一。<br>最终要想实现曲线渐变只能自己实现了。  </p>
<h4 id="颜色的生成">颜色的生成</h4><p>一共需要两个颜色，起始颜色和结束颜色。中间颜色的R、G、B值由progress线性生成。  </p>
<pre><code>CGFloat ratio = <span class="list">(<span class="keyword">float</span>)</span>i / <span class="list">(<span class="keyword">float</span>)</span>sectors <span class="comment">;</span>
CGFloat R = beginR + <span class="list">(<span class="keyword">endR</span> - beginR)</span> * ratio <span class="comment">;</span>
CGFloat G = beginG + <span class="list">(<span class="keyword">endG</span> - beginG)</span> * ratio <span class="comment">;</span>
CGFloat B = beginB + <span class="list">(<span class="keyword">endB</span> - beginB)</span> * ratio <span class="comment">;</span>
</code></pre><h4 id="渐变的生成">渐变的生成</h4><p>由于apple提供的api都是直线的，我就采取了微分的思想，将一个圆分为无数份，然后每一份绘制一点颜色。最终就形成了曲线渐变。</p>
<h4 id="最终的实现">最终的实现</h4><p>直接看代码吧。<a href="https://github.com/sxiaojian88/GradientProgressView.git" target="_blank" rel="external">demo在此</a></p>
<h3 id="rounded矩形渐变">rounded矩形渐变</h3><p>这个动画的实现就更有难度了。</p>
<p>动画由两个CAReplicatorLayer组成，一个完成前半部分，一个完成后半部份，两个layer的属性完全一致，仅仅是另外一个layer旋转了180度。最终效果是这样。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/roundedWaiting.gif" alt=""></p>
<p>一个CAReplicatorLayer的动画是这样的<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/roundedWaiting3.gif" alt=""><br>由于stroke end的取值是0-1，所以无法平滑的让stroke一直保持一样的长度。为了实现效果，我采取的方法是创建一个一样的CAReplicatorLayer并旋转180度。<br>于是效果变成了这样<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/roundedWaiting2.gif" alt=""></p>
<p>然后在这两个layer的superLayer添加mask，最终完成了要求的动画效果。<br>最难的是CAReplicatorLayer的创建，我创建了40个instance。</p>
<pre><code>replicator.instanceCount       = 40<span class="comment">;</span>
replicator.instanceDelay       = 0.01<span class="comment">;</span>
replicator.instanceColor       = [UIColor colorWithRed:1 green: 0.373 blue:0 alpha:0.99].CGColor<span class="comment">;</span>
replicator.instanceRedOffset   = 0.005<span class="comment">;</span>
replicator.instanceGreenOffset = 0.005<span class="comment">;</span>
replicator.instanceBlueOffset  = 0.005<span class="comment">;</span>
replicator.instanceAlphaOffset = -0.03<span class="comment">;</span>
replicator.instanceTransform   = CATransform3DIdentity<span class="comment">;</span>
</code></pre><p>里面的参数都经过大量的试错与微调才调出这个效果。<br>更多细节请看代码<br><a href="https://github.com/sxiaojian88/RoundedRectWaiting" target="_blank" rel="external">RoundedRectWaiting</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="圆形渐变">圆形渐变</h3><p>最近产品提了一个需求，要求进度条的进度可以大于1。效果如下<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/progress.gif" alt=""><br>效果图上卡，实际]]>
    </summary>
    
      <category term="iOS" scheme="http://sxiaojian.com/tags/iOS/"/>
    
      <category term="动画" scheme="http://sxiaojian.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在gerrit环境下创建私有Pods]]></title>
    <link href="http://sxiaojian.com/2015/11/11/gerrit-private-pod/"/>
    <id>http://sxiaojian.com/2015/11/11/gerrit-private-pod/</id>
    <published>2015-11-11T10:10:44.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在gerrit环境下创建私有Pods">在gerrit环境下创建私有Pods</h1><p>创建私有pod有两种方式，cocoapods的核心就是podspec文件，这个文件描述项目作者、主页、资源文件、版本等项目信息。<br>第一种方式是podspec放在spec Repo仓库（相当于索引仓库）中，cocoapod先找到spec repo 中的podspec文件，然后再根据文件中的仓库地址找到项目。  </p>
<p>第二种方式是把podspec文件放在自己的项目的主目录中   </p>
<h1 id="两种用法的优缺点">两种用法的优缺点</h1><p>第一种方法需要使用者来维护一个spec repo仓库，项目作者可以完全不用管。  </p>
<p>第二种方法需要项目作者来维护，需要项目作者知道cocopods的语法等相关知识。  </p>
<p>第一种方式的podfile    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">＃官方源</span><br><span class="line"><span class="built_in">source</span> <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line"><span class="comment">#本地私有源</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">'https://YOURHOST/apps/Specs-iOS'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'AlgoLib'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>第二种方式的Podfile    </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pod <span class="string">'AFNetworking'</span>, :git =&gt; <span class="string">'https://github.com/gowalla/AFNetworking.git'</span>, :tag =&gt; <span class="string">'0.7.0'</span></span><br></pre></td></tr></table></figure>
<p>使用第二种方法创建私有repo不需要阅读全文，只需要阅读 如何制作 podspec文件与podspec文件的语法，然后将podspec文件放入自己的项目主目录里。  </p>
<h1 id="在gerrit环境下的特殊性">在gerrit环境下的特殊性</h1><p>gerrit的项目的git地址带有邮箱，而私有pod要求同一个git地址能够被大家都能访问。 </p>
<p>解决的方法就是  </p>
<h4 id="使用Https">使用Https</h4><p>利用https地址。例如：<a href="https://YOURHOST/apps/Specs-iOS.git" target="_blank" rel="external">https://YOURHOST/apps/Specs-iOS.git</a><br>配置密码  </p>
<p>在gerrit个人页面－HTTP Password，生成http密码<br>username和password为git clone 需要的用户名和密码</p>
<h4 id="使用ssh">使用ssh</h4><p>利用ssh的地址。例如：ssh://YOURHOST/app<br>编辑~/.ssh/config文件<br>添加<br><code>Host YOURHOST  
    User YOURNAME</code> </p>
<h1 id="创建Pod私有源步骤：">创建Pod私有源步骤：</h1><p>1、创建两个git仓库，一个用来做私有的Spec Repo（相当于索引，用来找到相应的仓库中的代码），一个是我们自己的库<br>2、制作Podspec，并且推送到你创建的私有repo<br>3、使用Pod，在Podfile添加私有源来搭建项目  </p>
<h2 id="1、创建一个git仓库，用来做私有的Spec_Repo">1、创建一个git仓库，用来做私有的Spec Repo</h2><p>仓库建完后地址为<a href="https://YOURHOST/apps/Specs-iOS" target="_blank" rel="external">https://YOURHOST/apps/Specs-iOS</a>  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pod repo add Specs-iOS <span class="string">https:</span><span class="comment">//YOURHOST/apps/Specs-iOS </span></span><br><span class="line"><span class="comment">//这个操作实际上是git clone 到~/.cocoapods/repos/Specs-iOS里</span></span><br><span class="line">$ ls <span class="regexp">~/.cocoapods/</span>repos</span><br><span class="line">Specs-iOS master</span><br></pre></td></tr></table></figure>
<h2 id="2、制作Podspec文件">2、制作Podspec文件</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pod spec <span class="built_in">create</span> ［你的库名称］</span><br><span class="line">pod spec <span class="built_in">create</span> AlgoLib<span class="comment"></span><br><span class="line">//这个命令用来创建Podspec文件，生成了AlgoLib.podspec文件</span></span><br><span class="line">```  </span><br><span class="line"> </span><br><span class="line">然后编辑，可以按照以下格式 </span><br><span class="line">我已经把该省略的都省了</span><br></pre></td></tr></table></figure>
<p>Pod::Spec.new do |s|<br>    s.name = ‘AlgoLib’<br>    s.version = ‘1.0.0’<br>    s.summary = ‘[summary]’<br>    s.homepage = ‘<a href="http://www.huami-inc.com" target="_blank" rel="external">http://www.huami-inc.com</a>‘<br>    s.description = ‘[s.description]’<br>    s.author = {‘HM’ =&gt; ‘HM@smartdevices.com.cn’ }<br>    s.source = { :git =&gt; ‘<a href="https://YOURHOST/algo/AlgoLib" target="_blank" rel="external">https://YOURHOST/algo/AlgoLib</a>‘ }<br>    s.platform = :ios,’7.0’<br>    s.source_files = ‘src/*’<br>end  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">其中  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">s.source = &#123; :git =&gt; <span class="string">'https://YOURHOST/algo/AlgoLib'</span> &#125;</span><br><span class="line"><span class="comment">//这个是不需要指定tag的</span></span><br><span class="line">s.source       = &#123; :git =&gt; <span class="string">'https://YOURHOST/algo/AlgoLib'</span>, :tag =&gt; <span class="string">'0.1.1'</span> &#125;</span><br><span class="line"><span class="comment">//这个是需要指定tag的，需要远程仓库有相应tag</span></span><br></pre></td></tr></table></figure>
<h2 id="3、验证并推送到你的私有repo">3、验证并推送到你的私有repo</h2><p>在AlgoLib.podspec同目录下执行   </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint   </span><br><span class="line">可添加参数 <span class="comment">--allow-warnings来取消warnings</span></span><br><span class="line">可添加参数 <span class="comment">--verbose来获得更详细的信息</span></span><br></pre></td></tr></table></figure>
<p>首先验证的是AlgoLib.podspec的配置是否正确吗，然后验证仓库    </p>
<p>验证的时候实际上会将s.source指定的文件拉下来，取s.source_files指定的文件，然后编译。<br>如果因为warnings验证不通过，可以添加参数</p>
<p>如果没有错误和警告我们就可以推送到服务器了，推送使用的命令是 </p>
<p><code>pod repo push Specs-iOS AlgoLib.podspec</code></p>
<p>如果没有错误，但是有警告，我们就将警告解决，也可以加—allow-warnings来提交<br>普通仓库下这步不会有什么问题，在gerrit下，需要特殊处理 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pod repo push Specs-iOS AlgoLib<span class="class">.podspec</span></span><br><span class="line"><span class="comment">//这个操作实际上操作的是~/.cocoapods/repos/Specs-iOS这个本地git目录</span></span><br><span class="line"><span class="comment">//首先git pull </span></span><br><span class="line"><span class="comment">//然后 将AlgoLib.podspec复制到~/.cocoapods/repos/Specs-iOS/1.0.0/下  1.0.0为version号 version号要与tag号一致</span></span><br><span class="line"><span class="comment">//然后 git commit -a -m "add AlgiLib 1.0.0"</span></span><br><span class="line"><span class="comment">//然后 git push origin master</span></span><br></pre></td></tr></table></figure>
<p>在gerrit下，push这一步会出错  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.cocoapods/repos/Specs-iOS/AlgoLib</span><br><span class="line">git <span class="operator"><span class="keyword">reset</span> origin/<span class="keyword">master</span></span><br><span class="line">//需要重新提交以下，因为之前的配置不对无法提交</span><br><span class="line">git config <span class="keyword">user</span>.<span class="keyword">name</span> <span class="string">"你的gerrit name"</span></span><br><span class="line">git config <span class="keyword">user</span>.email <span class="string">"你的gerrit email"</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">"add AlgiLib 1.0.0"</span></span><br><span class="line">git push origin <span class="keyword">HEAD</span>:refs/<span class="keyword">for</span>/<span class="keyword">master</span></span></span><br></pre></td></tr></table></figure>
<p>到这一步，我们就可以用pod search 来搜索我们的库了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ pod search algolib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt; AlgoLib (<span class="number">1.0</span><span class="number">.0</span>)</span><br><span class="line">   [summary]</span><br><span class="line">   pod <span class="string">'AlgoLib'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">http:</span><span class="comment">//www.huami-inc.com</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//YOURHOST/algo/AlgoLib</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span><span class="number">.0</span> [Specs-iOS repo]</span><br></pre></td></tr></table></figure>
<h2 id="4、使用pod，在Podfile添加私有源来搭建项目">4、使用pod，在Podfile添加私有源来搭建项目</h2><p>使用时，在Podfile文件中添加本地私有源和官方源。如果没有添加本地私有源，它默认是用官方的repo，这样找不到本地的Pod；如果只是设置了本地私有源，就不会再去官方源中查找。 下面是Podfile内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#官方Cocoapods的源</span></span><br><span class="line">   <span class="built_in">source</span> <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">   <span class="comment">#本地私有源</span></span><br><span class="line">   <span class="built_in">source</span> <span class="string">'https://YOURHOST/apps/Specs-iOS'</span></span><br><span class="line">   </span><br><span class="line">   pod <span class="string">'AlgoLib'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>如果想每次pod install时更新私有repo ,使用这种格式<br><code>pod &#39;AlgoLib&#39;,:head</code></p>
<h2 id="注意">注意</h2><p>1、若是需要提交给官方，请使用</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register youremail</span><br><span class="line">查看信息</span><br><span class="line">pod trunk <span class="keyword">me</span></span><br><span class="line">将对应的pod推送到服务器</span><br><span class="line">pod turnk push</span><br></pre></td></tr></table></figure>
<p>2、使用pod install时，它首先会更新整个官方的源，而Cocoapods每天都有很多人提交，所以更新比较慢。所以，建议每过一段时间更新一下官方库，平常的时候，咱们可以在install或update加一个参数—no-repo-update让它不用更新。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod install --<span class="keyword">verbose</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></span><br><span class="line">pod <span class="keyword">update</span> --<span class="keyword">verbose</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在gerrit环境下创建私有Pods">在gerrit环境下创建私有Pods</h1><p>创建私有pod有两种方式，cocoapods的核心就是podspec文件，这个文件描述项目作者、主页、资源文件、版本等项目信息。<br>第一种方式是podspec放在spe]]>
    </summary>
    
      <category term="cocoapods" scheme="http://sxiaojian.com/tags/cocoapods/"/>
    
      <category term="gerrit" scheme="http://sxiaojian.com/tags/gerrit/"/>
    
      <category term="podspec" scheme="http://sxiaojian.com/tags/podspec/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS面试题与答案]]></title>
    <link href="http://sxiaojian.com/2015/09/08/ios-interview/"/>
    <id>http://sxiaojian.com/2015/09/08/ios-interview/</id>
    <published>2015-09-08T07:03:09.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="初级">初级</h1><h4 id="OC中创建线程的方法">OC中创建线程的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//创建线程的第一种方式</span></span><br><span class="line">   <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"universe"</span>];</span><br><span class="line">   </span><br><span class="line">   [thread start];  </span><br><span class="line">   <span class="comment">//创建线程的第二种方式，NSThread类方法</span></span><br><span class="line">   [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@"yuzhou"</span>];</span><br><span class="line">   <span class="comment">//创建线程的第三种方法  NSObject方法</span></span><br><span class="line">   [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"nsobject thread"</span>];</span><br><span class="line">   <span class="comment">//创建线程的第四种方式</span></span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *oprationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [oprationQueue addOperationWithBlock:^&#123;</span><br><span class="line">       <span class="comment">//这个block语句块在子线程中执行</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"oprationQueue"</span>);</span><br><span class="line">   &#125;];</span><br><span class="line"><span class="comment">//第五种创建线程的方式</span></span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *oprationQueue1 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   oprationQueue1<span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>;<span class="comment">//指定池子的并发数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//NSOperation 相当于java中的runnable接口，继承自它的就相当一个任务</span></span><br><span class="line">   <span class="built_in">NSInvocationOperation</span> *invation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"invation"</span>];</span><br><span class="line">   [oprationQueue1 addOperation:invation];<span class="comment">//将任务添加到池子里面，可以给池子添加多个任务，并且指定它的并发数</span></span><br><span class="line"><span class="comment">//第二个任务</span></span><br><span class="line">   <span class="built_in">NSInvocationOperation</span> *invation2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run2:) object:<span class="string">@"invocation2"</span>];</span><br><span class="line">   invation2<span class="variable">.queuePriority</span> = <span class="built_in">NSOperationQueuePriorityHigh</span>;<span class="comment">//设置线程优先级</span></span><br><span class="line">   [oprationQueue1 addOperation:invation2];</span><br><span class="line"><span class="comment">//---------------------GCD----------------------支持多核，高效率的多线程技术</span></span><br><span class="line"><span class="comment">//创建多线程第六种方式</span></span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"name"</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">//创建一个子线程</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="comment">// 子线程code... ..</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"GCD多线程"</span>);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//回到主线程</span></span><br><span class="line">       <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<span class="comment">//其实这个也是在子线程中执行的，只是把它放到了主线程的队列中</span></span><br><span class="line">           Boolean isMain = [<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line">           <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@"GCD主线程"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="ARC的实现原理">ARC的实现原理</h4><p>Automatic Reference Counting，自动引用计数，即ARC，可以说是WWDC2011和iOS5所引入的最大的变革和最激动人心的变化。  </p>
<p>ARC并不是垃圾收集，而且，引用计数也没有消失，只是变成自动而已。<br>当采用ARC后，代码只要这样写:<br><code>NSObject *obj = [[NSObject alloc] init];</code><br>ARC会自动将它变成:<br><code>NSObject *obj = [[NSObject alloc] init];
[obj release]; // **Added by ARC**</code><br>ARC 会自动帮助你添加 retain 和release/autorelease语句。</p>
<h4 id="self-bounds_与_self-frame_是什么区别">self.bounds 与 self.frame 是什么区别</h4><p><a href="http://honglu.me/2014/10/21/%E6%B5%85%E6%9E%90frame%E4%B8%8Ebounds/" target="_blank" rel="external">浅析frame与bounds</a></p>
<h4 id="category是什么_实现了什么功能">category是什么 实现了什么功能</h4><p><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a>  </p>
<h4 id="UITableView的insertRowAtIndexPaths怎么用">UITableView的insertRowAtIndexPaths怎么用</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[self.tableView beginUpdates]</span>;</span><br><span class="line"><span class="attr_selector">[self.tableView insertRowsAtIndexPaths:insertion withRowAnimation:UITableViewRowAnimationNone]</span>;</span><br><span class="line"><span class="comment">//更新数据源</span></span><br><span class="line"><span class="attr_selector">[self.tableView endUpdates]</span>;</span><br></pre></td></tr></table></figure>
<h4 id="dequeueResuableCellWithIdentifier_与_dequeueResuableCellWithIdentifier_forIndexPath_什么区别">dequeueResuableCellWithIdentifier 与 dequeueResuableCellWithIdentifier forIndexPath 什么区别</h4><p>直接看官方解释吧</p>
<blockquote>
<ul>
<li>(id)dequeueReusableCellWithIdentifier:(NSString *)identifier;  // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.</li>
<li>(id)dequeueReusableCellWithIdentifier:(NSString <em>)identifier forIndexPath:(NSIndexPath </em>)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered</li>
</ul>
</blockquote>
<h4 id="UITableView的estimateRowHeight是什么意思_起什么作用">UITableView的estimateRowHeight是什么意思 起什么作用</h4><p>参考<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">优化UITableViewCell高度计算的那些事</a>中的estimatedRowHeight  </p>
<p>7、UIViewContentMode都有什么 分别什么意思<br>8、NSUserdefault如何存对象 NSUserdefault的同步机制是什么<br>9、iOS应用程序的生命周期<br>10、UIViewController的生命周期  </p>
<h4 id="property都有哪些关键字，都是什么意思">property都有哪些关键字，都是什么意思</h4><p>找了半天，这篇最详细<a href="http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/" target="_blank" rel="external">@property属性关键字详解</a></p>
<h4 id="＃import和＃include的区别，@class代表什么">＃import和＃include的区别，@class代表什么</h4><p>区分 #include <x.h>与#include “x.h”的作用<br>“#include <x.h>“:它用于对系统自带的头文件的引用，编译器会在系统文件目录下去查找该文件.<br>“#include “x.h””:用户自定义的文件用双引号引用，编译器首先会在用户目录下查找，然后到安装目录中查找，最后在系统文件中查找。<br>在使用#include的时候要注意处理重复引用（这也是objc中#include与#import的区别）<br>例如：ClassA 与 ClassB同时引用了ClassC，不做重复引用处理的时候在ClassD中同时引用ClassA，ClassB编译会提示对ClassC重复引用的错误.<br>我们可以:  </x.h></x.h></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifndef</span> _CLASSC_H   </span><br><span class="line"><span class="hexcolor">#def</span>ine _CLASSC_H</span><br><span class="line"><span class="id">#include</span> <span class="string">"ClassC"</span>  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这样处理在编译时就不会有重复引用的错误出现（在objc中#import解决了这个问题，这是它们的区别）<br>“#import” 大部分功能和#include是一样的，但是他处理了重复引用的问题，我们在引用文件的时候不用再去自己进行重复引用处理.</p>
<p>@class与#import<br>二者的区别在于：<br>1.import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。<br>2.在头文件中， 一般只需要知道被引用的类的名称就可以了。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。<br>3.在编译效率方面考虑，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用@class则不会。<br>4.如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。<br>所以，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.  </p>
<h2 id="中级">中级</h2><h4 id="setValueForKey_与_setObjectForKey_什么区别">setValueForKey 与 setObjectForKey 什么区别</h4><p><a href="http://www.devdiv.com/setvalue_setobject_-blog-30695-56409.html" target="_blank" rel="external">setValue和setObject的区别</a></p>
<h4 id="两个应用之间怎么通讯">两个应用之间怎么通讯</h4><p>问题问的不好，想要的答案是URL Scheme</p>
<h4 id="说一下block内存管理">说一下block内存管理</h4><p>首先看这篇<a href="http://www.cnblogs.com/biosli/p/block_usage.html" target="_blank" rel="external">关于block使用的5点注意事项</a><br>详情参考《iOS高级编程 多线程和内存管理》</p>
<p>4、NSLayoutContraint包含哪些属性</p>
<h4 id="InterfaceBuilder中的约束如何在代码中修改">InterfaceBuilder中的约束如何在代码中修改</h4><p>可以连线获得NSLayoutConstraint对象，也可以通过<br><code>- (NSArray *)constraints NS_AVAILABLE_IOS(6_0);</code><br>这个属性来遍历<br>6、UITextView UITextField 有什么区别</p>
<h4 id="autolayout如何做动画">autolayout如何做动画</h4><p><a href="http://sxiaojian.com/2015/08/28/autolayout/">http://sxiaojian.com/2015/08/28/autolayout/</a><br>8、copy 与muteblecopy 什么区别<br>9、block copy 是什么意思 string copy 是什么意思<br>10、如何封装一个下拉刷新<br>11、OC中如何实现线程安全<br><a href="http://www.cnblogs.com/GarveyCalvin/p/4212611.html" target="_blank" rel="external">http://www.cnblogs.com/GarveyCalvin/p/4212611.html</a><br>12、iOS中的手势都是什么 手势类叫什么名字 手势间相互影响怎么解决<br>13、UIView的 alpha 与 opaque 是什么区别 根hidden有什么区别<br><a href="http://joeshang.github.io/2014/12/19/transparency-property-diffence-in-uiview/" target="_blank" rel="external">UIView中hidden、alpha、clear color与opaque的区别</a></p>
<h4 id="ios7增加了哪些api_ios8增加了哪些api_ios9">ios7增加了哪些api ios8增加了哪些api ios9</h4><p>这个纯粹看积累</p>
<h4 id="遍历NSArray中的对象都有什么方法">遍历NSArray中的对象都有什么方法</h4><p><a href="http://blog.sunnyxx.com/2014/04/30/ios_iterator/" target="_blank" rel="external">ios中集合遍历方法的比较和技巧</a><br>16、如何通过cell找到tableview 如何知道cell在哪个controller<br>17、UITableView的继承链 uibutton的继承链</p>
<h2 id="高级">高级</h2><p>1、说一下OC的runtime特性<br>2、响应者链是什么 touch事件如何传递 成为第一响应者要满足条件<br>3、NSRunloop是什么 都有哪些模式  </p>
<h4 id="content_hugging_priority_content_compression_resistance_priority是什么意思">content hugging priority  content compression resistance priority是什么意思</h4><p><a href="http://sxiaojian.com/2015/08/28/autolayout/">http://sxiaojian.com/2015/08/28/autolayout/</a><br>5、category是什么 实现了什么功能  </p>
<h2 id="一些第三方库不用添加代码就能起作用_原理是什么">一些第三方库不用添加代码就能起作用 原理是什么</h2><p>在load方法里，自动就执行了，不需要调用  </p>
<h4 id="other_link_flag_中的_objc_起什么作用">other link flag 中的 objc 起什么作用</h4><p>加载静态库中的category<br>8、UIScrollView的 decelerationRate flashScrollIndicators tracking dragging scrollsToTop 都是什么意思  </p>
<h2 id="上机题">上机题</h2><h4 id="如何删除array1［@1，@2，@3］中_array2［@1，@2］_有的对象">如何删除array1［@1，@2，@3］中 array2［@1，@2］ 有的对象</h4><p>方法一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    NSMutableArray *<span class="built_in">array</span> = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>].mutableCopy;</span><br><span class="line">    NSArray *array2 = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">5</span>];</span><br><span class="line">    NSMutableIndexSet *indexes = [[NSMutableIndexSet alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (NSNumber *num in array2) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="built_in">array</span>[i] isEqual:num]) &#123;</span><br><span class="line">                [indexes addIndex:i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">array</span> removeObjectsAtIndexes:indexes];</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,<span class="built_in">array</span>);</span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">方法二</span><br></pre></td></tr></table></figure>
<pre><code>NSMutableArray <span class="variable">*array</span> = <span class="variable">@[</span><span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@3</span>,<span class="variable">@4</span>,<span class="variable">@5</span>].mutableCopy;
NSArray <span class="variable">*array2</span> = <span class="variable">@[</span><span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@5</span>];
[array removeObjectsInArray:array2];
NSLog(<span class="variable">@"</span><span class="variable">%@</span><span class="string">",array);</span>
</code></pre><p>```<br>2、修改InterfaceBuilder中已添加约束的view的frame</p>
<p>3、等宽子视图</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="初级">初级</h1><h4 id="OC中创建线程的方法">OC中创建线程的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="l]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[performSelector的总结]]></title>
    <link href="http://sxiaojian.com/2015/09/08/perform-selector/"/>
    <id>http://sxiaojian.com/2015/09/08/perform-selector/</id>
    <published>2015-09-08T04:01:20.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="线程无关方法">线程无关方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">performSelector</span>:<span class="value">(SEL)aSelector</span></span>;  </span><br><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">performSelector</span>:<span class="value">(SEL)aSelector withObject:(id)object</span></span>;  </span><br><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">performSelector</span>:<span class="value">(SEL)aSelector withObject:(id)object1 withObject:(id)object2</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法，均为同步执行，与线程无关，主线程和子线程中均可调用。等同于直接调用该方法。在需要动态的去调用方法的时候去使用。<br>例如：[self performSelector:@selector(test2)];与[self test2];执行效果上完全相同。</p>
<h2 id="Delayed_perform">Delayed perform</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay inModes:<span class="params">(<span class="variable">NSArray</span> *)</span>modes;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay;</span></span><br></pre></td></tr></table></figure>
<p>1、这两个方法为异步执行<br>2、这两个方法只能在主线程中执行，其它线程不执行<br>3、即使delay传参为0，也不会立即执行，而是在next runloop执行<br>4、可用于当点击UI中一个按钮会触发一个消耗系统性能的事件，在事件执行期间按钮会一直处于高亮状态，此时可以调用该方法去异步的处理该事件，就能避免上面的问题。  </p>
<p>在方法未到执行时间之前，取消方法为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">cancelPreviousPerformRequestsWithTarget</span>:<span class="value">(id)aTarget selector:(SEL)aSelector object:(id)anArgument</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">cancelPreviousPerformRequestsWithTarget</span>:<span class="value">(id)aTarget</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="on_mainthread">on mainthread</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(<span class="variable">NSArray</span> *)</span>array;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait;</span></span><br></pre></td></tr></table></figure>
<p>1、这两个方法，在主线程和子线程中均可执行，均会在主线程中调aSelector方法<br>2、如果设置wait为NO:等待当前线程执行完以后，主线程才会执行aSelector方法；<br>3、设置为YES：不等待当前线程执行完，就在主线程上执行aSelector方法。<br>4、第二个方法使用默认的模式（NSDefaultRunLoopMode）。<br>有些人博客上的说法很多都是错误的，~~ 比如wait为YES是等待后执行、如果当前线程为主线程就马上执行 ~~。</p>
<h2 id="参数">参数</h2><h4 id="直接使用perform方法参数要求是对象">直接使用perform方法参数要求是对象</h4><p>perform方法要求传入参数必须是对象，如果方法本身的参数是int，直接传NSNumber会导致得到的int参数不正确</p>
<h4 id="传多个参数的解决方法">传多个参数的解决方法</h4><p>方法一</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) anotherMethod &#123;</span><br><span class="line">     <span class="keyword">id</span> target = <span class="keyword">self</span>; </span><br><span class="line">     SEL selector = <span class="keyword">@selector</span>(methodWithFirst:second:third:); </span><br><span class="line">     <span class="comment">// 首先第一个参数和第二个参数是self和selector</span></span><br><span class="line">     <span class="comment">// 剩下的参数可以是对象或者基本数据类型，根据方法需要填写参数类型</span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">void</span> (*MethodType)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>, <span class="keyword">id</span>); </span><br><span class="line">     <span class="comment">// 这个方法实际上返回的是IMP类型，为了方便调用，强转为MethodType</span></span><br><span class="line">     MethodType methodToCall = (MethodType)[target methodForSelector:selector]; </span><br><span class="line">     methodToCall(target, selector, @(<span class="number">1</span>), @(<span class="number">2</span>), @(<span class="number">3</span>));</span><br><span class="line">      &#125; </span><br><span class="line">- (<span class="keyword">void</span>)methodWithFirst:(<span class="keyword">id</span>) object second:(<span class="keyword">id</span>) secondObject third:(<span class="keyword">id</span>) thirdObject &#123;</span><br><span class="line"> <span class="comment">// Code here </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SEL</span> selector = @selector(methodWithFirst:andSecond:andThird:);</span><br><span class="line">   <span class="type">NSMethodSignature</span> *signature = [self methodSignatureForSelector: selector];</span><br><span class="line">   <span class="type">NSInvocation</span> *invocation = [<span class="type">NSInvocation</span> invocationWithMethodSignature: signature];</span><br><span class="line"></span><br><span class="line">   [invocation setSelector: selector];</span><br><span class="line">   </span><br><span class="line">   [invocation setTarget: self];</span><br><span class="line">   //前两个参数为self与selector，其它参数要从<span class="number">2</span>开始</span><br><span class="line">   [invocation setArgument: &amp;first  atIndex: <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   [invocation setArgument: &amp;second atIndex: <span class="number">3</span>];</span><br><span class="line">   </span><br><span class="line">   [invocation setArgument: &amp;third  atIndex: <span class="number">4</span>];</span><br><span class="line">   </span><br><span class="line">   [invocation invoke];</span><br><span class="line"></span><br><span class="line">   [invocation getReturnValue: &amp;<span class="literal">result</span>];</span><br><span class="line"></span><br><span class="line">   <span class="type">NSLog</span>(@<span class="string">"NSInvocation      : %@"</span>, <span class="literal">result</span>);</span><br></pre></td></tr></table></figure>
<p>使用category  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">extend</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObjects:(<span class="built_in">NSArray</span> *)objects;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withParameters:(<span class="keyword">void</span> *)firstParameter, ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">extend</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObjects:(<span class="built_in">NSArray</span> *)objects &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    [invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">    [invocation setSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> objects) &#123;</span><br><span class="line">        [invocation setArgument:(<span class="keyword">void</span> *)&amp;object atIndex:++i];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([signature methodReturnLength]) &#123;</span><br><span class="line">        <span class="keyword">id</span> data;</span><br><span class="line">        [invocation getReturnValue:&amp;data];</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withParameters:(<span class="keyword">void</span> *)firstParameter, ... &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [signature numberOfArguments];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    [invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">    [invocation setSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    [invocation setArgument:&amp;firstParameter atIndex:<span class="number">2</span>];</span><br><span class="line">    va_list arg_ptr;</span><br><span class="line">    va_start(arg_ptr, firstParameter);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">3</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">void</span> *parameter = va_arg(arg_ptr, <span class="keyword">void</span> *);</span><br><span class="line">        [invocation setArgument:&amp;parameter atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">    </span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([signature methodReturnLength]) &#123;</span><br><span class="line">        <span class="keyword">id</span> data;</span><br><span class="line">        [invocation getReturnValue:&amp;data];</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个方法使用数组，所以不能传nil，必须传对象</span></span><br><span class="line">[self <span class="string">performSelector:</span><span class="annotation">@selector</span>(<span class="string">methodWithFirst:</span><span class="string">second:</span><span class="string">third:</span>) <span class="string">withObjects:</span>[NSArray <span class="string">arrayWithObjects:</span>@<span class="string">"1"</span>, @<span class="string">"2"</span>, @<span class="string">"3"</span>, nil]];</span><br><span class="line"><span class="comment">//第二个方法采用多个参数，可以传nil，必须传对象</span></span><br><span class="line">[self <span class="string">performSelector:</span><span class="annotation">@selector</span>(<span class="string">methodWithFirst:</span><span class="string">second:</span><span class="string">third:</span>) <span class="string">withParameters:</span>(<span class="typename">void</span> *)(@<span class="number">1</span>),nil,@<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h2 id="返回值">返回值</h2><p>在intel处理器中，obj_msgSend将方法的返回值存储在eax寄存器中。但是当方法返回结构体比如NSRect时，方法编译后为objc_msgSend_stret，这个方法将传递一个额外的参数：一个指向返回值内存的指针<br>苹果的官方文档说 </p>
<blockquote>
<p>For methods that return anything other than an object, use NSInvocation.  </p>
</blockquote>
<p>performSelector编译后使用objc_msgSend。如果返回值为结构体，本该使用objc_msgSend_stret却使用了objc_msgSend，就会导致崩溃。解释的不是很细致，请看原文</p>
<blockquote>
<p>Apple aren’t kidding when they mention this. This is because performSelector: uses objc_msgSend. If you use objc_msgSend to call a method that requires objc_msgSend_stret, the function will think the first parameter is the secret struct pointer, when in fact it’s the self pointer. When the function returns, it corrupts the memory pointed to by self by overwriting it with the return value. Next time you try to use the object, you get weird and wonderful crashes.<br>Only use performSelector: when the selector returns an object. If the selector returns a struct, then you risk corrupting memory, even if you don’t use the return value. If the method doesn’t return an object, then use NSInvocation instead, because it is capable of determining the correct message dispatch function to use.   </p>
</blockquote>
<p>只有方法返回值为对象或者无返回值是才使用performSelector:方法，其它情况使用NSInvocation代替。<br>下面这个category检查了返回值</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">SafePerformSelector</span>) </span></span><br><span class="line">-(<span class="keyword">id</span>) performSelectorSafely:(SEL)aSelector; </span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span>(<span class="title">SafePerformSelector</span>) </span></span><br><span class="line">-(<span class="keyword">id</span>) performSelectorSafely:(SEL)aSelector; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(aSelector != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="built_in">NSParameterAssert</span>([<span class="keyword">self</span> respondsToSelector:aSelector]);</span><br><span class="line">     <span class="built_in">NSMethodSignature</span>* methodSig = [<span class="keyword">self</span> methodSignatureForSelector:aSelector]; </span><br><span class="line">     <span class="keyword">if</span>(methodSig == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* retType = [methodSig methodReturnType]; </span><br><span class="line">     <span class="keyword">if</span>(strcmp(retType, @encode(<span class="keyword">id</span>)) == <span class="number">0</span> || strcmp(retType, @encode(<span class="keyword">void</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">self</span> performSelector:aSelector]; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"-[%@ performSelector:@selector(%@)] shouldn't be used. The selector doesn't return an object or void"</span>, [<span class="keyword">self</span> className], <span class="built_in">NSStringFromSelector</span>(aSelector)); </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line">      &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="线程无关方法">线程无关方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line]]>
    </summary>
    
      <category term="ios" scheme="http://sxiaojian.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Auto Layout 的经验之谈]]></title>
    <link href="http://sxiaojian.com/2015/08/28/autolayout/"/>
    <id>http://sxiaojian.com/2015/08/28/autolayout/</id>
    <published>2015-08-28T07:39:24.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Auto_Layout_的经验之谈">Auto Layout 的经验之谈</h1><h4 id="Auto_Layout_的本质原理">Auto Layout 的本质原理</h4><p>Auto Layout 的本质是用一些约束条件对元素进行约束，从而让他们显示在我们想让他们显示的地方。<br>约束主要分为以下几种：  </p>
<ul>
<li>相对于父 view 的约束。如：距离上边距 10，左边距 10。  </li>
<li>相对于前一个元素的约束。如：距离上一个元素 20，距离左边的元素 5 等。  </li>
<li>对齐类约束。如：跟父 view 左对齐，跟上一个元素居中对齐等。  </li>
<li>相等约束。如：跟父 view 等宽。  </li>
</ul>
<h4 id="使用快捷键快速添加约束">使用快捷键快速添加约束</h4><p>  <img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-28%20下午1.12.10.png" alt=""><br>  可以通过如图所示快捷键快速创建与父视图关系的约束</p>
<h4 id="使用鼠标拖拽添加约束">使用鼠标拖拽添加约束</h4><p><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-28%20下午1.54.05.png" alt=""><br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-28%20下午1.53.38.png" alt=""><br>按住control键从一个View拖至另一个View。<br>按住option键来切换是否需要margins<br>按住shift键可以多选，一次添加多个约束</p>
<h4 id="Masonry">Masonry</h4><p>这是一个第三方的非常好用的开源框架，以前我以为Autolayout只能用xib了，否则代码量太大了，但是Masonry让用代码写Autolayout成为可能，而且非常强大，清晰好用，示例：  </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIEdgeInsets padding = UIEdgeInsetsMake<span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line">[view1 mas_makeConstraints:^<span class="params">(MASConstraintMaker *make)</span> &#123;</span><br><span class="line">    make.top.equalTo<span class="params">(superview.mas_top)</span>.with.<span class="built_in">offset</span><span class="params">(padding.top)</span>;</span><br><span class="line">    make.left.equalTo<span class="params">(superview.mas_left)</span>.with.<span class="built_in">offset</span><span class="params">(padding.left)</span>;</span><br><span class="line">    make.bottom.equalTo<span class="params">(superview.mas_bottom)</span>.with.<span class="built_in">offset</span><span class="params">(-padding.bottom)</span>;</span><br><span class="line">    make.right.equalTo<span class="params">(superview.mas_right)</span>.with.<span class="built_in">offset</span><span class="params">(-padding.right)</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="AutoresizingMark">AutoresizingMark</h4><p>当我们使用Autoresizing时，运行时会自动根据autoresizingMask的特性为view添加Constraint， 我们可以通过下面这个API来决定启用还是关闭这一特性（NO为关闭）：<br><code>- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag NS_AVAILABLE_IOS(6_0);</code><br>这个属性在xib中默认是NO, 在不用xib时默认是YES, 也就是如果使用代码创建Constraint时，需要设置该属性为NO, Masonry自动帮我们做了这一操作，所以用Masonry不需要设置改属性。</p>
<h4 id="Update_Constraint_与_Update_Frame">Update Constraint 与 Update Frame</h4><p>Update Constraint 是根据InterfaceBuilder上View的位置来改变约束的值<br>Update Frame 是根据约束的规则来改变View的frame，使View放置在正确的位置。</p>
<h4 id="代码中改变约束的值">代码中改变约束的值</h4><p>interface中的任何对象都可以连线到代码中，约束也不例外。<br>连线后改变NSLayoutConsraint的constant的值。</p>
<h4 id="margins">margins</h4><p>iOS8上关于UIView的Margin新增了3个APIs</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0); </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0); </span><br><span class="line">- (<span class="keyword">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>在iOS 8中，可以使用layoutMargins去定义view之间的间距,该属性只对AutoLayout布局生效。</p>
<p>因此AutoLayout中NSLayoutAttribute的枚举值有了相应的更新：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeBottomMargin&#10;NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeLeadingMargin&#10;NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeTrailingMargin&#10;NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeCenterXWithinMargins&#10;NS_ENUM_AVAILABLE_IOS(8_0),&#10;NSLayoutAttributeCenterYWithinMargins&#10;NS_ENUM_AVAILABLE_IOS(8_0),</span><br></pre></td></tr></table></figure>
<h4 id="对UIScrollView使用_Auto_Layout">对UIScrollView使用 Auto Layout</h4><p><a href="http://blog.csdn.net/lihuiqwertyuiop/article/details/39320091" title="参考这篇文章" target="_blank" rel="external">参考这篇文章</a></p>
<h4 id="Size_Classes">Size Classes</h4><p><a href="http://wangjordy.github.io/blog/2015/04/03/autolayout-%5B%3F%5D/" title="参考这篇文章" target="_blank" rel="external">参考这篇文章</a><br><a href="http://www.51ios.net/iosknow/87.html" title="这篇" target="_blank" rel="external">这篇</a></p>
<h4 id="Content_Hugging_和_Content_Compression_Resistance">Content Hugging 和 Content Compression Resistance</h4><p>这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。关于intrinsic content size官方的解释</p>
<blockquote>
<p>Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.  </p>
</blockquote>
<p>UIView中关于Content Hugging 和 Content Compression Resistance的方法有：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis&#10;- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis&#10;- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis&#10;- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis</span><br></pre></td></tr></table></figure>
<p>Hugging priority 确定view有多大的优先级阻止自己变大。</p>
<p>Compression Resistance priority确定有多大的优先级阻止自己变小。</p>
<p>很抽象，其实content Hugging就是要维持当前view在它的optimal size（intrinsic content size），可以想象成给view添加了一个额外的width constraint，此constraint试图保持view的size不让其变大：</p>
<p>view.width &lt;= optimal size</p>
<p>此constraint的优先级就是通过上面的方法得到和设置的，content Hugging默认为250.</p>
<p>Content Compression Resistance就是要维持当前view在他的optimal size（intrinsic content size），可以想象成给view添加了一个额外的width constraint，此constraint试图保持view的size不让其变小：<br>view.width &gt;= optimal size<br>此默认优先级为750.<br>这两个属性分别可以设置水平方向和垂直方向上的，而且一个默认优先级是250， 一个默认优先级是750. 因为这两个很有可能与其他Constraint冲突，所以优先级较低。</p>
<h4 id="布局动画">布局动画</h4><p>动画是UI体验的重要部分，更改布局以后的动画也非常关键。只需要把layoutIfNeeded放到animation block中即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;[UIView animateWithDuration:0.5 animations:^&#123;&#10;    //change view&#39;s layoutconstraint&#10;    [view layoutIfNeeded];&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="容易出现的错误">容易出现的错误</h4><p>因为涉及约束问题，因此约束模型下的所有可能出现的问题这里都会出现，具体来说包括两种：</p>
<ul>
<li>Ambiguous Layout 布局不能确定</li>
<li>Unsatisfiable Constraints 无法满足约束</li>
</ul>
<p>布局不能确定指的是给出的约束条件无法唯一确定一种布局，也即约束条件不足，无法得到唯一的布局结果。这种情况一般添加一些必要的约束或者调整优先级可以解决。无法满足约束的问题来源是有约束条件互相冲突，因此无法同时满足，需要删掉一些约束。两种错误在出现时均会导致布局的不稳定和错误，Ambiguous可以被容忍并且选择一种可行布局呈现在UI上，Unsatisfiable的话会无法得到UI布局并报错。 对于不能确定的布局，可以通过调试时暂停程序，在debugger中输入</p>
<p><code>po [[UIWindow keyWindow] _autolayoutTrace]</code></p>
<p>来检查是否存在Ambiguous Layout以及存在的位置，来帮助添加条件。</p>
<h4 id="使用原则">使用原则</h4><p>总结一下autolayout的使用原则:  </p>
<ul>
<li>所添加的约束,必须是能够确定一个视图的位置和大小的  </li>
<li>所添加的约束,必须是可以计算的,能唯一得出 宽高或者边界值的  </li>
<li>所添加的约束,必须是不冲突的,否则会抛出异常  </li>
<li>所添加的约束,在storyboard上默认是相邻的最近的视图之间的约束  </li>
<li>所添加的约束,最好是以一个视图为基准添加,这样有利于修改,牵一发而动全身</li>
<li>所添加的约束，最好模块化，一个模块内的约束修改不会影响到别的模块</li>
<li>Auto Layout 与 Auto Resizing 是可以相互兼容的。如果一个vuew内部没有添加约束，则view内使用的是Auto Resizing布局，可以手动改frame。如果添加了约束，则view内使用Auto Layout 布局</li>
<li>apple并不推荐我们删除约束再添加约束，会引发一些问题，推荐的做法是改变约束的值，cell复用时要注意。  </li>
</ul>
<h4 id="Auto_Layout进阶">Auto Layout进阶</h4><p>AutoLayout 进阶 Demo，宽高比约束、比例约束、不等约束、视差约束、低优先级约束等高级用法，无需写码即可进行复杂页面布局，Demo 还动态模拟了各屏幕下的效果。来自百度知道 iOS 小组的内部分享，源码请戳：<a href="https://github.com/philcn/Auto-Layout-Showcase" target="_blank" rel="external">Auto-Layout-Showcase</a></p>
<p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">这篇文章</a>是百度知道团队最近对 UITableViewCell 利用 AutoLayout 自动高度计算和 UITableView 滑动优化的一个总结。<br>UITableView+FDTemplateLayoutCell，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">github链接请戳我</a></p>
<p>百度知道团队还开源了UIView-FDCollapsibleConstraints,让一个View消失时跟View相关的约束也同时变为0<br><a href="https://github.com/forkingdog/UIView-FDCollapsibleConstraints" target="_blank" rel="external">github链接请戳我</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Auto_Layout_的经验之谈">Auto Layout 的经验之谈</h1><h4 id="Auto_Layout_的本质原理">Auto Layout 的本质原理</h4><p>Auto Layout 的本质是用一些约束条件对元素进行约束，从而让他们显示在]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[改变NSView backgroundColor的最简单方法]]></title>
    <link href="http://sxiaojian.com/2015/08/14/NSView-backgroundColor/"/>
    <id>http://sxiaojian.com/2015/08/14/NSView-backgroundColor/</id>
    <published>2015-08-14T03:46:16.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<p>首先创建一个category 文件名为NSView+backgroundColor</p>
<p>NSView+backgroundColor.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSView</span> (<span class="title">OSXBGColorExtension</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSColor</span> *backgroundColor;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>NSView+backgroundColor.m  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSView+backgroundColor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">OSXBGColorExtension</span>)</span></span><br><span class="line">- (<span class="built_in">NSColor</span> *) backgroundColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorRef</span> colorRef = <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.backgroundColor</span>;</span><br><span class="line">    <span class="built_in">NSColor</span> *theColor = [<span class="built_in">NSColor</span> colorWith<span class="built_in">CGColor</span>:colorRef];</span><br><span class="line">    <span class="keyword">return</span> theColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setBackgroundColor:(<span class="built_in">NSColor</span> *)backgroundColor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> setWantsLayer:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.backgroundColor</span> = backgroundColor<span class="variable">.CGColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后在User Defined Runtime Attributes里面直接设置颜色 key为backgroundColor</p>
<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-14%20上午11.49.49.png" alt=""></p>
<p>这种方法比在drawrect里面改颜色要好多了，IB中或者代码都可以使用，一个操作或者一句话搞定</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先创建一个category 文件名为NSView+backgroundColor</p>
<p>NSView+backgroundColor.h</p>
<figure class="highlight objectivec"><table><tr><td class="]]>
    </summary>
    
      <category term="NSView" scheme="http://sxiaojian.com/tags/NSView/"/>
    
      <category term="backgroundColor" scheme="http://sxiaojian.com/tags/backgroundColor/"/>
    
      <category term="mac" scheme="http://sxiaojian.com/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac/ios开发小知识]]></title>
    <link href="http://sxiaojian.com/2015/08/13/mac-ios-develop-knowledge/"/>
    <id>http://sxiaojian.com/2015/08/13/mac-ios-develop-knowledge/</id>
    <published>2015-08-13T09:13:41.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mac开发中动画的使用">mac开发中动画的使用</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[NSAnimationContext runAnimationGroup:^<span class="list">(<span class="keyword">NSAnimationContext</span> *context)</span> <span class="collection">&#123;</span><br><span class="line">//your code</span><br><span class="line">&#125;</span> completionHandler:<span class="comment">^&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>与ios中的UIView动画类似<br>还有第二种用法  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSAnimationContext</span> beginGrouping];</span><br><span class="line"><span class="built_in">NSAnimationContext</span><span class="variable">.currentContext</span><span class="variable">.duration</span> = animagionDuration; </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAnimationContext</span><span class="variable">.currentContext</span><span class="variable">.completionHandler</span> = <span class="literal">nil</span>;</span><br><span class="line">   <span class="comment">//your code </span></span><br><span class="line">[<span class="built_in">NSAnimationContext</span> endGrouping];</span><br></pre></td></tr></table></figure>
<h3 id="对autolayout的约束使用动画">对autolayout的约束使用动画</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[self.someConstraint.animator setConstant:100]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>ios中只需正常赋值然后调用 [superView layoutIfNeed];</p>
<h3 id="旋转NSView">旋转NSView</h3><p>rotate NSView</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sender.wantsLayer = YES<span class="comment">;</span></span><br><span class="line">sender.layer.affineTransform = CGAffineTransformMakeRotation(M_PI)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="mac开发中动画的使用">mac开发中动画的使用</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><sp]]>
    </summary>
    
      <category term="ios" scheme="http://sxiaojian.com/tags/ios/"/>
    
      <category term="mac" scheme="http://sxiaojian.com/tags/mac/"/>
    
      <category term="mac" scheme="http://sxiaojian.com/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac开发中使用自定义NSTableCellView]]></title>
    <link href="http://sxiaojian.com/2015/08/11/Mac-NSTableView/"/>
    <id>http://sxiaojian.com/2015/08/11/Mac-NSTableView/</id>
    <published>2015-08-11T08:09:52.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<p>首先创建一个新的mac工程，不勾选StoryBoard<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.15.27.png" alt=""><br>打开MainMenu.xib ，选中主window并向window中拖入一个NSTableView，并加上约束。<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.20.52.png" alt=""><br>选中tableview，并设置colloms为1,将header选项的勾去掉,并删掉Table Column下面的Table Cell View<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.25.35.png" alt=""><br>创建一个empty的xib文件命名为CustomCell.xib<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.26.54.png" alt=""><br>往CustomCell中拖入tablecellview，可以去掉不需要的控件，添加上自己需要的控件,将cell的identifier改为CustomCell<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.35.33.png" alt=""><br>创建一个CustomCell类，继承NSTableCellView,将xib内cell的Class改为CustomCell，然后就可以连线了<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.42.39.png" alt=""><br>CustomCell.h 代码 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Cocoa</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">NSTableCellView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> color: <span class="type">NSColorWell</span>!</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label1: <span class="type">NSTextField</span>!</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label2: <span class="type">NSTextField</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(dirtyRect: NSRect)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.drawRect(dirtyRect)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drawing code here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样cell的工作就完成了  </p>
<p>将TableView自身与TableView的datasource和delegate都连接到appdelegate里面.注意一共需要连三条线<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.51.51.png" alt=""></p>
<p>appdelegate的代码  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Cocoa</span></span><br><span class="line"></span><br><span class="line">@<span class="type">NSApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">NSObject</span>, <span class="title">NSApplicationDelegate</span> , <span class="title">NSTableViewDataSource</span>,<span class="title">NSTableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableview: <span class="type">NSTableView</span>! &#123;</span><br><span class="line">        <span class="keyword">didSet</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.tableview.registerNib(<span class="type">NSNib</span>(nibNamed: <span class="string">"CustomCell"</span>, bundle: <span class="literal">nil</span>)!, forIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> window: <span class="type">NSWindow</span>!</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">numberOfRowsInTableView</span><span class="params">(tableView: NSTableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: NSTableView, viewForTableColumn tableColumn: NSTableColumn?, row: Int)</span></span> -&gt; <span class="type">NSView</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> cell = tableview.makeViewWithIdentifier(<span class="string">"CustomCell"</span>, owner: <span class="keyword">self</span>) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        cell.label1.stringValue = <span class="string">"============="</span></span><br><span class="line">        cell.label2.stringValue = <span class="string">"+++++++++++++"</span></span><br><span class="line">        cell.color.color = <span class="type">NSColor</span>.yellowColor()</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: NSTableView, heightOfRow row: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">(aNotification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Insert code here to initialize your application</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">applicationWillTerminate</span><span class="params">(aNotification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Insert code here to tear down your application</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就全部完成了。我故意将cell文件单独放在xib里，是为了方便复用。<br>mac下自定义cell几乎跟ios下的一样，但是相关文章实在太少，于是我将整个过程记录下来，供大家参考。<br>源代码可以在<a href="https://github.com/sxiaojian88/MacNSTableView" target="_blank" rel="external">这里</a>下载,运行环境Xcode 6.3＋,swift 1.2</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先创建一个新的mac工程，不勾选StoryBoard<br><img src="http://7xiyql.com1.z0.glb.clouddn.com/屏幕快照%202015-08-11%20下午4.15.27.png" alt=""><br>打开MainMenu.x]]>
    </summary>
    
      <category term="mac" scheme="http://sxiaojian.com/tags/mac/"/>
    
      <category term="nstableview" scheme="http://sxiaojian.com/tags/nstableview/"/>
    
      <category term="mac" scheme="http://sxiaojian.com/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在vps上搭建shadowsocks服务器实现翻墙]]></title>
    <link href="http://sxiaojian.com/2015/07/30/vps-shadowsocks/"/>
    <id>http://sxiaojian.com/2015/07/30/vps-shadowsocks/</id>
    <published>2015-07-30T06:09:52.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos_6下">centos 6下</h1><h2 id="用一键安装脚本">用一键安装脚本</h2><p><strong>本脚本适用环境</strong>：<br>系统支持：CentOS 32或64位<br>内存要求：≥128M</p>
<p>注意替换<strong>yourpasswd</strong>和你的服务器ip地址<strong>$IP</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/<span class="keyword">sh</span></span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> /<span class="keyword">opt</span>/software</span><br><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/software</span><br><span class="line"></span><br><span class="line">yum install build-essential autoconf libtool libssl-dev gcc openssl openssl-devel git -<span class="keyword">y</span></span><br><span class="line"></span><br><span class="line">rm -rf /<span class="keyword">opt</span>/software/shadowsocks-libev</span><br><span class="line"></span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/shadowsocks/shadowsocks-libev.git</span><br><span class="line"><span class="keyword">cd</span> shadowsocks-libev</span><br><span class="line">./configure</span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span>=$(<span class="keyword">find</span> / -<span class="built_in">type</span> <span class="keyword">f</span> -name <span class="string">"*shadowsocks.json"</span>);<span class="keyword">cp</span> $<span class="keyword">f</span> /root/config.json</span><br><span class="line"></span><br><span class="line">#IP=$<span class="number">1</span></span><br><span class="line">#IP=$(ifconfig|awk <span class="string">'/inet addr:/'</span>|<span class="keyword">grep</span> -<span class="keyword">v</span> <span class="number">127.0</span>.<span class="number">0.1</span>|<span class="keyword">grep</span> -oP <span class="string">'(?&lt;=inet addr:)[^ ]+'</span>|head -<span class="number">1</span>)</span><br><span class="line">[[ -<span class="keyword">n</span> $<span class="number">1</span> ]] &amp;&amp; IP=$<span class="number">1</span> || IP=$(ifconfig|awk <span class="string">'/inet /'</span>|<span class="keyword">grep</span> -<span class="keyword">v</span> <span class="number">127.0</span>.<span class="number">0.1</span>|<span class="keyword">grep</span> -oP <span class="string">'(?&lt;=[ :])(([0-9]+.)&#123;3&#125;.[0-9]+)'</span>|head -<span class="number">1</span>)</span><br><span class="line">sed -<span class="keyword">i</span> <span class="string">'s/127.0.0.1/'</span>$IP<span class="string">'/;s/1080/443/;s/barfoo!/yourpasswd/;s/null/"aes-256-cfb"/'</span> /root/config.json</span><br><span class="line"></span><br><span class="line">#echo <span class="string">"nohup /usr/local/bin/ss-server -c /root/config.json &gt; /dev/null 2&gt;&amp;1 &amp;"</span> &gt;&gt; /etc/rc.local</span><br><span class="line">[[ $(<span class="keyword">grep</span> -<span class="keyword">c</span> ss-server /etc/rc.local) == <span class="number">0</span> ]] &amp;&amp; <span class="keyword">echo</span> <span class="string">"nohup /usr/local/bin/ss-server -c /root/config.json &gt; /dev/null 2&gt;&amp;1 &amp;"</span> &gt;&gt; /etc/rc.local||<span class="keyword">echo</span> <span class="string">'it has be set to run on startup !'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"shadowsocks-libev installed !"</span></span><br><span class="line"><span class="keyword">sleep</span> <span class="number">3</span> </span><br><span class="line">#chkconfig sshd off</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"server will be restarted !"</span></span><br><span class="line"><span class="keyword">sleep</span> <span class="number">3</span> #defaul<span class="variable">t:</span> seconds</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> ss.<span class="keyword">sh</span>  //将上面的脚本复制进去，不会<span class="keyword">vi</span>请先搜索<span class="keyword">vi</span>的用法</span><br><span class="line">chmod +<span class="keyword">x</span> ss.<span class="keyword">sh</span></span><br><span class="line">./ss.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>安装完成后即已后台启动 shadowsocks ，运行：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> ss-server | <span class="keyword">grep</span> -<span class="keyword">v</span> <span class="keyword">ps</span> | <span class="keyword">grep</span> -<span class="keyword">v</span> <span class="keyword">grep</span></span><br></pre></td></tr></table></figure>
<p>可以查看进程是否存在。<br>脚本安装完成后，会将 shadowsocks-libev 加入开机自启动<br>需要修改参数的话 直接修改/root/config.json文件即可  </p>
<h1 id="ubuntu下">ubuntu下</h1><h2 id="1、安装ss">1、安装ss</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="operator"><span class="keyword">update</span></span><br><span class="line">apt-<span class="keyword">get</span> <span class="keyword">install</span> python-pip &amp; pip <span class="keyword">install</span> shadowsocks</span><br><span class="line">apt-<span class="keyword">get</span> <span class="keyword">install</span> python-m2crypto</span></span><br></pre></td></tr></table></figure>
<h2 id="2、配置">2、配置</h2><p>创建配置文件ss.conf<br>内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"<span class="attribute">server</span>" : <span class="value"><span class="string">"123.123.213.213"</span></span>,  </span><br><span class="line">"<span class="attribute">server_port</span>" : <span class="value"><span class="number">6666</span></span>,</span><br><span class="line">"<span class="attribute">local_address</span>":<span class="value"><span class="string">"127.0.0.1"</span></span>,</span><br><span class="line">"<span class="attribute">local_port</span>" : <span class="value"><span class="number">1080</span></span>,</span><br><span class="line">"<span class="attribute">password</span>" : <span class="value"><span class="string">"23333"</span></span>,</span><br><span class="line">"<span class="attribute">timeout</span>" : <span class="value"><span class="number">600</span></span>,</span><br><span class="line">"<span class="attribute">method</span>" : <span class="value"><span class="string">"aes-256-cfb"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、启动">3、启动</h2><p>启动时使用命令</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c <span class="regexp">/root/</span>ss.conf</span><br></pre></td></tr></table></figure>
<p><strong>tips</strong>:加密方式推荐使用rc4-md5，因为 RC4 比 AES 速度快好几倍，如果用在路由器上会带来显著性能提升。旧的 RC4 加密之所以不安全是因为 Shadowsocks 在每个连接上重复使用 key，没有使用 IV。</p>
<p><strong>ps</strong>:<br>1、ss客户端的本地IP和端口, 一般设为127.0.0.1 1080;<br>2、SS不同于VPN，它是走socks5协议的，一般搭配浏览器食用，对于terminal的get,wget等走http是没有帮助的。<br>3、程序员肯定会大量使用terminal的, 在terminal中翻墙请看文章<a href="http://sxiaojian.com/2015/07/30/shadowsocks-terminal/">在terminal中使用shadowsocks</a></p>
<h2 id="4、开机启动">4、开机启动</h2><p>在/etc/rc.local中添加启动命令。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.<span class="keyword">local</span></span><br></pre></td></tr></table></figure>
<p>在exit 0 前面添加</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>ssserver -c <span class="regexp">/root/</span>.ss.conf &gt;<span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>查看ss是否已经开启，用下面这个:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> ss-server</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="centos_6下">centos 6下</h1><h2 id="用一键安装脚本">用一键安装脚本</h2><p><strong>本脚本适用环境</strong>：<br>系统支持：CentOS 32或64位<br>内存要求：≥128M</p>
<p>注意替换<s]]>
    </summary>
    
      <category term="shadowsocks" scheme="http://sxiaojian.com/tags/shadowsocks/"/>
    
      <category term="vpn" scheme="http://sxiaojian.com/tags/vpn/"/>
    
      <category term="vps" scheme="http://sxiaojian.com/tags/vps/"/>
    
      <category term="linux" scheme="http://sxiaojian.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一张图让你掌握git]]></title>
    <link href="http://sxiaojian.com/2015/07/29/git-picture/"/>
    <id>http://sxiaojian.com/2015/07/29/git-picture/</id>
    <published>2015-07-29T07:45:33.000Z</published>
    <updated>2016-07-04T05:13:49.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/20130725102400984.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xiyql.com1.z0.glb.clouddn.com/20130725102400984.png" alt=""></p>
]]>
    </summary>
    
      <category term="git" scheme="http://sxiaojian.com/tags/git/"/>
    
      <category term="git" scheme="http://sxiaojian.com/categories/git/"/>
    
  </entry>
  
</feed>
